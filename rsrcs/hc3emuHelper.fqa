{"name":"hc3emuHelper","type":"com.fibaro.genericDevice","apiVersion":"1.3","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_3787"},"sections":{"items":[]}},"head":{"title":"quickApp_device_3787"}}},"uiView":[],"useUiView":true,"uiCallbacks":[],"quickAppVariables":[],"typeTemplateInitialized":true,"userDescription":""},"initialInterfaces":[],"files":[{"name":"main","isMain":true,"isOpen":true,"content":"local HELPER_UUID = \"hc3emu-00-01\"\nlocal HELPER_VERSION = \"1.0.0\"\nlocal connections = {}\nlocal DBG = true\nlocal function DEBUG(...) if DBG then print(string.format(...)) end end\n\nfunction QuickApp:onInit()\n   print(\"Helper\")\n   self:updateProperty(\"quickAppUuid\",HELPER_UUID)\n   self:updateProperty(\"model\",HELPER_VERSION)\nend\n\nlocal function doCommand(msg)\n   DEBUG(\"MSG: %s\",msg)\n   local req = json.decode(msg)\n   local res = {api[req.method:lower()](req.path,req.data)}\n   return json.encode(res)..\"\\n\"\nend\n\nlocal function startConnection(key,ip,port)\n   local sock = net.TCPSocket()\n   local cmd \n\n   local function err(err) \n      DEBUG(\"Disconnected from %s %s\",key,tostring(err)) \n      if connections[key] then connections[key]:close() end\n      connections[key]=nil \n   end\n\n   local function readParts(data,n,parts)\n      --print(\"RP\",n,data)\n      if data == nil then return err('No data') end\n      parts[#parts+1]= data\n      if n < 1 then return cmd(table.concat(parts)) end\n      sock:read({\n         success=function(data) readParts(data,n-1,parts) end,\n         error = err\n      })\n   end\n\n   local function read()\n      sock:read({\n         success=function(data)\n            --print(\"FP\",1,data)\n            if not data then return err('No data') end\n            local n = tonumber(data:sub(1,3))\n            if not n then return end\n            data = data:sub(5)\n            if n == 1 then return cmd(data) end\n            sock:read({\n               success=function(resp) readParts(resp,n-2,{data}) end,\n               error=err\n            })\n         end,\n         error=err\n      })\n   end\n\n   local function writeParts(str,i,n,n0)\n      if n < 1 then return read() end\n      sock:write(str:sub(i,i+n0-1),{\n         success=function() writeParts(str,i+n0,n-1,n0) end,\n         error=err\n      })\n   end\n\n   local n0 = 500\n   local function write(str)\n      local len = #str\n      local n = (len-1) // n0 + 1\n      local p = str:sub(1,1+n0-1)\n      sock:write(string.format(\"%03d:%s\",n,p),{\n         success=writeParts(str,1+n0,n-1,n0),\n         error=err\n      })\n   end\n\n   function cmd(msg)\n      local resp = \"Pong\\n\"\n      if msg~=\"Ping\\n\" then\n         resp = doCommand(msg) \n      end\n      write(resp)\n   end\n   \n   local function connected()\n      connections[key]=sock\n      DEBUG(\"Connected to %s\",key)\n      read()\n   end\n\n   sock:connect(ip,port,{success = connected, error = err})\nend\n\nfunction QuickApp:connect(ip,port)\n   local key = ip..\":\"..port \n   if connections[key] then return end\n   startConnection(key,ip,port)\nend\n\nfunction QuickApp:close(ip,port)\n   local key = ip..\":\"..port\n   if connections[key] then \n      DEBUG(\"Close called\")\n      connections[key]:close()\n      connections[key] = nil\n   end\nend\n"}]}