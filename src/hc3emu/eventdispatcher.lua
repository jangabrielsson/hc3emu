Emulator = Emulator
local E = Emulator.emulator
local fmt = string.format
local copas = require("copas")
local json = require("hc3emu.json")
local lclass = require("hc3emu.class")

local function refreshStatePoller(dispatcher)
  local path = "/refreshStates"
  local last,events=1,nil
  local suffix = "&lang=en&rand=7784634785"
  while true do
    local data, status = E:HC3Call("GET", (last and path..("?last="..last) or path) .. suffix, nil, true)
    --print(status)
    if status ~= 200 then
      E:ERRORF("Failed to get refresh state: %s",status)
      return
    end
    assert(data, "No data received")
    ---@diagnostic disable-next-line: undefined-field
    last = math.floor(data.last) or last
    ---@diagnostic disable-next-line: undefined-field
    events = data.events
    if events ~= nil then
      for _, event in pairs(events) do
         E:DEBUGF("rawrefresh","RRefresh %s:%s",event.type,json.encode(event.data))
         dispatcher:newEvent(event)
      end
    end
    --if next(data.changes) then print("CHANGE:",json.encode(data.changes)) end
    copas.pause(E._refreshInterval or 0.01)
  end
end

local filter = { 
  -- GlobalVariableAddedEvent = true, GlobalVariableChangedEvent = true, GlobalVariableRemovedEvent = true, RoomModifiedEvent = true, 
  -- RoomCreatedEvent = true, RoomRemovedEvent = true, 
  -- SectionModifiedEvent = true, SectionCreatedEvent = true, SectionRemovedEvent = true,
  -- CustomEventModifiedEvent = true, CustomEventCreatedEvent = true, CustomEventRemovedEvent = true,
  -- DeviceModifiedEvent = true, DevicePropertyUpdatedEvent = true,
  -- CentralSceneEvent = true
}

local EventHandler = {}
local EventQueue = lclass('EventQueue')
function EventQueue:__init()
  self.queue = {}
  self.listeners = {}
  self.first = 0
  self.last = 1
end
function EventQueue:addEvent(event,exclListener)
  if not filter[event.type] then E:DEBUGF("refresh","Refresh %s:%s",event.type,json.encode(event.data)) end
  if not event.created then event.created = os.time() end
  self.first = self.first + 1
  self.queue[self.first] = event
  if self.first-self.last > 250 then
    self.queue[self.last] = nil
    self.last = self.last + 1
  end
  for l,_ in pairs(self.listeners) do 
    if l ~= exclListener then 
      l(event) 
    end 
  end
end
function EventQueue:addListener(listener) self.listeners[listener] = true end
function EventQueue:removeListener(listener) self.listeners[listener] = nil end

local ResourceDB = require("hc3emu.resources")

local EventDispatcher = lclass('EventDispatcher')
function EventDispatcher:__init(offline)
  self.queue = EventQueue()
  self.db = ResourceDB()
  self.offline = offline==true
end
function EventDispatcher:start(api) 
  self.api = api
  self.db.hc3 = api.hc3
  self:setupHandlers()
  if not E.DBG.offline then
    E:addThread(E.systemRunner,refreshStatePoller,self)
  end
end

function EventDispatcher:addListener(listener) return self.queue:addListener(listener) end
function EventDispatcher:removeListener(listener) return self.queue:removeListener(listener) end
function EventDispatcher:addEvent(event,exclListener) return self.queue:addEvent(event, exclListener) end

local function singleKey(key,a)
  local key2,val = next(a)
  if key2 ~= key then return false end
  return next(a,key) == nil
end

local eventMap = {
  RoomCreatedEvent = "/rooms/",
  RoomModifiedEvent = "/rooms/",
  SectionCreatedEvent = "/sections/",
  SectionModifiedEvent = "/sections/",
  DeviceCreatedEvent = "/devices/",
  DeviceModifiedEvent = "/devices/",
  UserCreatedEvent = "/users/",
  UserModifiedEvent = "/users/",
}

local deviceEvent = {
  DeviceCreatedEvent = true,
  DeviceModifiedEvent = true,
  DeviceRemovedEvent = true,
  DevicePropertyUpdatedEvent = true,
}

function EventDispatcher:complement(typ,data) -- Event lacking data from HC3
  if not singleKey('id',data) then return data end
  local path = eventMap[typ]
  return path and self.api.hc3.get(path..data.id) or data 
end

function EventDispatcher:newEvent(event,lcl)
  local str,localEvent = nil,nil
  if filter[event.type] then
    str = event.type.." "..json.encode(event.data)
  end
  if deviceEvent[event.type] then
    local id = event.data.id or event.data.deviceId
    local qa = E:getQA(id)
    if qa and not qa.isProxy then localEvent = true end
  end
  if self.offline or localEvent then -- Running offline
    if str then E:DEBUG("Offline/LocalQA EventDispatcher:newEvent %s",str) end
    local res,code = self:updateDB(event.type,event.data)
    if code < 206 then
      self.queue:addEvent(event)
    end
    return res,code
  end
  -- Online mode
  if lcl then -- generated by api.* call
    if str then E:DEBUG("Local EventDispatcher:newEvent %s",str) end
    local res,code = self:updateHC3(event.type,event.data)
    if code < 206 then
      self:updateDB(event.type,event.data)
    end
    return res,code
  else -- generated from HC3
    if str then E:DEBUG("HC3 EventDispatcher:newEvent %s",str) end
    local data = self:complement(event.type,event.data)
    local res,code = self:updateDB(event.type,data)
    self.queue:addEvent(event)
    return res,code
  end
end

function EventDispatcher:newLocalEvent(event)
  return self:newEvent(event,true)
end

function EventDispatcher:updateDB(typ,data)
  local handler = EventHandler[typ]
  if handler then
    return handler(data, false)
  end
  return nil,999
end

function EventDispatcher:updateHC3(typ,data)
  local handler = EventHandler[typ]
  if handler then
    return handler(data, true)
  end
  return nil,501
end

-- RefreshStateSubscriber subcribes to queue...

function EventDispatcher:setupHandlers()
  local db = self.db
  local api = self.api
  local hc3 = api.hc3
  local EH = EventHandler
  local offline = self.offline

  local function regEvent(typ)
    EH[typ] = function(data,event,ext)
      if ext then return nil,501 
      else return nil,501 end
    end
  end

  -- Global variables
  function EH.GlobalVariableAddedEvent(data,ext)
    if ext then 
      return hc3.post('/globalVariables',{name=data.variableName,value=data.value})
    else
      return db:create('globalVariables',{name=data.variableName, value=data.value})
    end
  end
  function EH.GlobalVariableRemovedEvent(data,ext)
    if ext then return hc3.delete('/globalVariables/'..data.variableName,{})
    else return db:delete('globalVariables',data.variableName) end
  end
  function EH.GlobalVariableChangedEvent(data,ext)
    if ext then return hc3.put('/globalVariables/'..data.variableName,{value=data.value})
    else return db:modify('globalVariables',{name=data.variableName, value=data.value}) end
  end

  -- Rooms
  function EH.RoomCreatedEvent(data,ext)
    if ext then return hc3.post('/rooms',data)
    else return db:create('rooms',data) end
  end
  function EH.RoomRemovedEvent(data,ext)
    if ext then return hc3.delete('/rooms/'..data.id,{})
    else return db:delete('rooms',data.id) end
  end
  function EH.RoomModifiedEvent(data,ext)
    if ext then return hc3.put('/rooms/'..data.id,data)
    else return db:modify('rooms',data) end
  end

  -- Sections
  function EH.SectionCreatedEvent(data,ext)
    if ext then return hc3.post('/sections',data)
    else return db:create('sections',data) end
  end
  function EH.SectionRemovedEvent(data,ext)
    if ext then return hc3.delete('/sections/'..data.id,{})
    else return db:delete('sections',data.id) end
  end
  function EH.SectionModifiedEvent(data,ext)
    if ext then return hc3.put('/sections/'..data.id,data)
    else return db:modify('sections',data) end
  end

  -- CustomEvents
  function EH.CustomEventCreated(data,ext)
    if ext then return hc3.post('/customEvents',data)
    else return db:create('customEvents',data) end
  end
  function EH.CustomEvent(data,ext)
    if ext then return hc3.post('/customEvents',{name=data.eventName})
    else print("SEND CustomEvent") return nil,200 end
  end
  function EH.CustomEventRemoved(data,ext)
    if ext then return hc3.delete('/customEvents/'..data.name,{})
    else return db:delete('customEvents',data.name) end
  end
  function EH.CustomEventModified(data,ext)
    if ext then return hc3.put('/customEvents/'..data.name,data)
    else return db:modify('customEvents',data) end
  end

  -- Devices, a little bit tricky as we have to take care of emulated and proxies...
  function EH.DeviceCreatedEvent(data,updateHC3)
    if updateHC3 then
      -- From emulator, taken care of by the emulator. 
      return nil,201 -- hc3.post('/devices',data) Don't try to create device on HC3
    else 
      -- From HC3
      return db:create('devices',data)
    end
  end
  function EH.DeviceRemovedEvent(data,updateHC3) -- Device removed
    local qa = E:getQA(data.id)
    if updateHC3 then -- local event
      return hc3.delete('/devices/'..data.id,{})    -- wait for HC3 event
    else -- HC3 event
      local res,code = db:delete('devices',data.id)
      if code < 206 and qa then qa:remove() end
      return res,code
    end
  end
  function EH.DeviceModifiedEvent(data,updateHC3)
    local qa = E:getQA(data.id)
    if updateHC3 then -- local event
      return hc3.put('/devices/'..data.id,data)  -- wait for HC3 event
    else -- HC3 event
      local id = data.id         
      local ndata = { id = id }
      for _,key in ipairs({'name','roomID','enabled','visible'}) do
        ndata[key] = data[key]
      end
      local res,code = db:modify('devices',ndata)
      if code < 206 and qa then 
        local QA = qa.qa  
        for k,v in pairs(ndata) do QA[k] = data[k] end -- Move to QuickApp object.
        qa:restart() -- Restart
      end
      return res,code
    end
  end
  function EH.DevicePropertyUpdatedEvent(d,updateHC3)
    local qa = E:getQA(d.id)
    if updateHC3 then
      return hc3.post('/plugins/updateProperty',{ -- wait for HC3 event
        deviceId=d.id,
        propertyName=d.property,
        value=d.newValue
      }) 
    else -- From HC3
      local res,code = db:modifyProp('devices',d)
      if code < 206 and qa then qa:watchesProperty(d.property,d.newValue) end
      return res,code
    end
  end

  -- Weather 
  function EH.WeatherChangedEvent(data,ext)
    if ext then return data,200 --hc3.put('/weather',data) -- We can't change the weather...
    else return db:modify('weather',data) end
  end

  -- panels/location
  function EH.LocationCreatedEvent(data,ext)
    if ext then return hc3.post('/panels/location',data)
    else return db:create('panels/location',data) end
  end
  function EH.LocationRemovedEvent(data,ext)
    if ext then return hc3.delete('/panels/location/'..data.id,{})
    else return db:delete('panels/location',data.sectionId) end
  end
  function EH.LocationModifiedEvent(data,ext)
    if ext then return hc3.put('/panels/location/'..data.id,data)
    else return db:modify('panels/location',data) end
  end

  -- user
  function EH.UserCreatedEvent(data,ext)
    if ext then return hc3.post('/users',data)
    else return db:create('users',data) end
  end
  function EH.UserRemovedEvent(data,ext)
    if ext then return hc3.delete('/users/'..data.id,{})
    else return db:delete('users',data.id) end
  end
  function EH.UserModifiedEvent(data,ext)
    if ext then
      local ndata = table.copy(data)
      ndata.id = nil
      return hc3.put('/users/'..data.id,ndata)
    else 
      return db:modify('users',data) 
    end
  end
  
  ----------------------------
  -- function EH.PluginChangedViewEvent(data,updateHC3)
  --   local qa = E:getQA(data.id)
  --   if not qa then return nil,999 end
  --   if updateHC3 then
  --     print("HC3 changed view")
  --   else 
  --     print("Local changed view")
  --   end
  -- end

  -- Events below we don't generate from emulator, only pass on if coming from HC3
  ------------ Alarm
  regEvent('AlarmPartitionArmedEvent')
  regEvent('HomeArmStateChangedEvent')
  regEvent('HomeDisarmStateChangedEvent')
  regEvent('HomeBreachedEvent')
  
  --------------- Misc
  regEvent('DeviceActionRanEvent')
  regEvent('CentralSceneEvent')
  regEvent('SceneActivationEvent')
  regEvent('AccessControlEvent')
  regEvent('PluginChangedViewEvent')
  regEvent('WizardStepStateChangedEvent')
  regEvent('UpdateReadyEvent')
  regEvent('DeviceChangedRoomEvent')
  regEvent('PluginProcessCrashedEvent')
  regEvent('SceneStartedEvent')
  regEvent('SceneFinishedEvent')
  regEvent('SceneRunningInstancesEvent')
  regEvent('SceneRemovedEvent')
  regEvent('SceneModifiedEvent')
  regEvent('SceneCreatedEvent')
  regEvent('OnlineStatusUpdatedEvent')
  regEvent('ActiveProfileChangedEvent')
  regEvent('ClimateZoneChangedEvent')
  regEvent('ClimateZoneSetpointChangedEvent')
  regEvent('ClimateZoneTemperatureChangedEvent')
  regEvent('NotificationCreatedEvent')
  regEvent('NotificationRemovedEvent')
  regEvent('NotificationUpdatedEvent')
  regEvent('QuickAppFilesChangedEvent')
  regEvent('ZwaveDeviceParametersChangedEvent')
  regEvent('ZwaveNodeAddedEvent')
  regEvent('ZwaveNodeWokeUpEvent')
  regEvent('ZwaveNodeWentToSleepEvent')
  regEvent('RefreshRequiredEvent')
  regEvent('DeviceFirmwareUpdateEvent')
  regEvent('GeofenceEvent')
  regEvent('DeviceNotificationState')
  regEvent('DeviceInterfacesUpdatedEvent') -- DeviceInterfacesUpdatedEvent:{"id":3995}
  regEvent('EntitiesAmountChangedEvent')
  regEvent('ActiveTariffChangedEvent')
  regEvent('UserModifiedEvent')
  regEvent('SprinklerSequenceStartedEvent')
  regEvent('SprinklerSequenceFinishedEvent')
  regEvent('DeviceGroupActionRanEvent')
  regEvent('PowerMetricsChangedEvent')
end

return EventDispatcher